# BEST_PRACTICE

https://graphql.org/learn/best-practices/

GraphQL仕様は、ネットワーク、認可、ページネーションの処理など、APIが直面するいくつかの重要な問題について意図的に沈黙しています。
これは、GraphQLの使用時にこれらの問題の解決策がないことを意味するものではなく、GraphQLとは何かという説明の範囲外であり、代わりに一般的な慣行にすぎないということです。

このセクションの記事は福音と見なされるべきではなく、場合によっては他のアプローチを支持して無視されることがあります。
 GraphQLサービスの設計とデプロイに関してFacebookで開発された哲学の一部を紹介する記事もあれば、HTTP経由でのサービスや承認の実行などの一般的な問題を解決するためのより戦術的な提案もあります。

以下は、GraphQLサービスが保持するより一般的なベストプラクティスと意見のあるスタンスの簡単な説明です。
ただし、このセクションの各記事では、これらおよびその他のトピックについてさらに詳しく説明します。

## HTTP

GraphQLは通常、サービスのすべての機能を表現する単一のエンドポイントを介してHTTP経由で提供されます。
これは、それぞれが単一のリソースを公開する一連のURLを公開するREST APIとは対照的です。
GraphQLはリソースURLのスイートと一緒に使用できますが、これによりGraphiQLなどのツールでの使用が難しくなります。

これについて詳しくは、HTTPでの配信をご覧ください。

## JSON (with GZIP)

通常、GraphQLサービスはJSONを使用して応答しますが、GraphQL仕様ではJSONを必要としません。
JSONは、より良いネットワークを約束するAPIレイヤーにとって奇妙な選択のように思えるかもしれません

本番環境のGraphQLサービスでGZIPを有効にし、クライアントがヘッダーを送信するように奨励することをお勧めします。

```
Accept-Encoding: gzip
```

JSONはクライアントおよびAPI開発者にとっても非常に馴染みがあり、読みやすく、デバッグも簡単です。
実際、GraphQL構文はJSON構文に一部影響を受けています。

## Versioning

GraphQLサービスが他のREST APIとまったく同じようにバージョン管理されることを妨げるものはありませんが、GraphQLは、GraphQLスキーマの継続的な進化のためのツールを提供することにより、バージョン管理を回避することに強い意見を持っています。

なぜほとんどのAPIバージョンを使用するのですか？
APIエンドポイントから返されるデータの制御が制限されている場合、変更は重大な変更と見なすことができ、重大な変更には新しいバージョンが必要です。
APIに新しい機能を追加するために新しいバージョンが必要な場合、頻繁にリリースすることと、多くのインクリメンタルバージョンを使用することと、APIの理解可能性および保守容易性との間にトレードオフが生じます。

対照的に、GraphQLは明示的に要求されたデータのみを返すため、破壊的な変更を作成することなく、新しいタイプおよびそれらのタイプの新しいフィールドを介して新しい機能を追加できます。
これにより、常に変更の破壊を避け、バージョンレスAPIを提供するという一般的な慣行が生まれました。

## Nullability

「null」を認識するほとんどのタイプシステムは、共通タイプとそのタイプのnull許容バージョンの両方を提供します。
これにより、明示的に宣言されない限り、デフォルトタイプには「null」が含まれません。
ただし、GraphQL型システムでは、すべてのフィールドはデフォルトでnull可能です。
これは、データベースや他のサービスに裏打ちされたネットワークサービスで問題が発生する可能性があるためです。
データベースがダウンし、非同期アクションが失敗し、例外がスローされる可能性がありました。
単純なシステム障害だけでなく、リクエスト内の個々のフィールドに異なる承認ルールを設定できる場合、承認は細かくなります。

すべてのフィールドをヌル可能にデフォルト設定することにより、これらの理由のいずれかにより、そのフィールドがリクエストに対して完全に失敗するのではなく、「ヌル」が返される場合があります。
代わりに、GraphQLは、要求された場合にフィールドが「null」を返さないことをクライアントに保証するタイプの非nullバリアントを提供します。
代わりに、エラーが発生した場合、前の親フィールドは代わりに「null」になります。

GraphQLスキーマを設計するとき、失敗する可能性のあるすべての問題、および「null」が失敗したフィールドの適切な値である場合に留意することが重要です。
通常はそうですが、時々そうではありません。
そのような場合は、null以外の型を使用してその保証を行います。

## Pagination

GraphQL型システムでは、一部のフィールドで値のリストを返すことができますが、値の長いリストのページ分割はAPIデザイナーに任されています。
ページネーションにはさまざまなAPIデザインがあり、それぞれに長所と短所があります。

通常、長いリストを返す可能性のあるフィールドは、引数「`first`」および「`after`」を受け入れて、リストの特定の領域を指定できるようにします。
「`after`」は、リスト内の各値の一意の識別子です。

最終的には、機能豊富なページネーションを使用してAPIを設計することで、「`Connections`」と呼ばれるベストプラクティスパターンが生まれました。
[Relay](https://facebook.github.io/relay/)などのGraphQLの一部のクライアントツールは、接続パターンを認識しており、GraphQL APIがこのパターンを使用する場合、クライアント側の[Pagination](https://graphql.org/learn/pagination/)を自動的にサポートできます。

## Server-side Batching & Caching

GraphQLは、サーバー上でクリーンなコードを記述できるように設計されています。
すべてのタイプのすべてのフィールドには、その値を解決するための焦点を絞った単一目的関数があります。
ただし、追加の考慮なしに、単純なGraphQLサービスは非常に「チャット」になるか、データベースからデータを繰り返しロードする可能性があります。

これは通常、バッチ処理によって解決されます。
バッチ処理では、バックエンドからのデータに対する複数の要求が短時間で収集され、Facebookの[DataLoader](https://github.com/facebook/dataloader)などのツールを使用して、基になるデータベースまたはマイクロサービスへの単一の要求でディスパッチされます。

